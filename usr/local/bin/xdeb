#!/usr/bin/env bash

# O Void Linux usa /bin/sh por padr√£o.

# version: 1.6

clear

# ----------------------------------------------------------------------------------------

# Internacionaliza√ß√£o com gettext

export TEXTDOMAIN=xdeb
export TEXTDOMAINDIR=/usr/share/locale

# export TEXTDOMAINDIR=../../share/locale/

# ----------------------------------------------------------------------------------------

# Por que o man ignora o idioma no Void Linux?

# O mandoc (usado por Void Linux) n√£o respeita LANG ou LC_MESSAGES para selecionar p√°ginas 
# localizadas. Ele simplesmente busca a primeira p√°gina que encontrar no caminho padr√£o, 
# geralmente em /usr/share/man/man1, e ignora subdiret√≥rios como pt_BR.

# ‚úÖ Solu√ß√µes poss√≠veis

# Substituir a vers√£o em ingl√™s pela vers√£o em portugu√™s

# Se voc√™ quiser que man xdeb exiba a vers√£o em portugu√™s por padr√£o:


# Isso ignora o banco de dados e abre o arquivo diretamente. Se isso funcionar, sabemos 
# que o conte√∫do est√° correto e o problema √© s√≥ com o √≠ndice.

# man -l /usr/share/man/pt_BR/man1/xdeb.1

# echo $MANPATH
# export MANPATH="/usr/share/man:/usr/share/man/pt_BR"

# Criar um alias para abrir diretamente a vers√£o em portugu√™s

# manpt() {
#    man -l "/usr/share/man/pt_BR/man1/$1.1"
# }


# manpt xdeb.1




# Directories and filenames

# Esse comando define XDEB_PKGROOT como o diret√≥rio atual ($(pwd)) caso a vari√°vel n√£o 
# esteja definida.
# XDEB_PKGROOT="$(realpath -m "${XDEB_PKGROOT-"$(pwd)"}")"


# Explica√ß√£o:

# :-/tmp/xdeb define /tmp/xdeb como valor padr√£o, se XDEB_PKGROOT n√£o estiver definido.

# O realpath -m garante que o caminho seja absoluto e resolvido corretamente.

# As demais pastas (XDEB_WORKDIR, XDEB_DESTDIR, etc.) s√£o criadas dentro de XDEB_PKGROOT, 
# ent√£o ao mudar isso, tudo vai para /tmp.

# Se quiser, tamb√©m pode exportar essa vari√°vel antes de rodar o script.

# export XDEB_PKGROOT=/tmp/xdeb
# xdeb


XDEB_PKGROOT="$(realpath -m "${XDEB_PKGROOT:-/tmp/xdeb}")"



XDEB_WORKDIR="$(realpath -m "${XDEB_WORKDIR-"${XDEB_PKGROOT}/workdir"}")"
XDEB_DESTDIR="$(realpath -m "${XDEB_DESTDIR-"${XDEB_PKGROOT}/destdir"}")"
XDEB_DATADIR="$(realpath -m "${XDEB_DATADIR-"${XDEB_PKGROOT}/datadir"}")"
XDEB_BINPKGS="$(realpath -m "${XDEB_BINPKGS-"${XDEB_PKGROOT}/binpkgs"}")"
XDEB_SHLIBS="$(realpath -m "${XDEB_SHLIBS-"${XDEB_PKGROOT}/shlibs"}")"

# Options
XDEB_OPT_DEPS="${XDEB_OPT_DEPS-false}"
XDEB_OPT_SYNC="${XDEB_OPT_SYNC-false}"
XDEB_OPT_QUIT="${XDEB_OPT_QUIT-false}"
XDEB_OPT_EXTRACT="${XDEB_OPT_EXTRACT-true}"
XDEB_OPT_INSTALL="${XDEB_OPT_INSTALL-false}"
XDEB_OPT_REGISTER="${XDEB_OPT_REGISTER-true}"
XDEB_OPT_CLEAN_DIR="${XDEB_OPT_CLEAN_DIR-false}"
XDEB_OPT_LAZY_SONAME="${XDEB_OPT_LAZY_SONAME-false}"
XDEB_OPT_FIX_CONFLICT="${XDEB_OPT_FIX_CONFLICT-true}"
XDEB_OPT_WARN_CONFLICT="${XDEB_OPT_WARN_CONFLICT-true}"

# XDEB_OPT_POST_EXTRACT="${XDEB_OPT_STDIN_POST_EXTRACT-}"
# XDEB_BUILD_OPTIONS

XDEB_REFUSE=false
XDEB_SUFFIX=""

# ----------------------------------------------------------------------------------------

function intro() {


[ -d "${XDEB_PKGROOT:-}" ] && list=$(ls "${XDEB_PKGROOT}") || list=""


echo "
# ----------------------------------------------------------------------------------------

$(gettext "Base directory of the packaging process"): ${XDEB_PKGROOT}

$list

$(gettext "These folders make up the structure used by the xdeb script when converting .deb packages 
to the native Void Linux format (.xbps). Each directory plays a specific role 
in the content extraction, modification, and packaging steps.

Below is a description of each of them:")


üìÅ workdir

$(gettext "Function"):

$(gettext "Temporary folder used to store files extracted directly from the .deb file, before being organized.")

$(gettext "Example content"):

control.tar.*

data.tar.*

debian-binary

$(gettext "Summary"):

$(gettext "This is where the .deb is initially unpacked.")

üìÅ datadir

$(gettext "Function"):

$(gettext "Where the .deb package control metadata is extracted (such as control, maintainer, version, etc).")

$(gettext "Example content"):

$(gettext "Control File

Other control files (preinst, postinst, etc.)")

$(gettext "Summary"):

$(gettext "Contains information about the package (name, version, description, etc.).")

üìÅ destdir

$(gettext "Function"):

$(gettext "Directory where the actual package files are extracted (what will be installed on the system).")

$(gettext "Example content"):

/usr/bin/mousepad
/usr/lib/libmousepad.so.0.0.0
/usr/lib/mousepad/plugins/libmousepad-plugin-gspell.so
/usr/lib/mousepad/plugins/libmousepad-plugin-shortcuts.so
/usr/share/applications/org.xfce.mousepad-settings.desktop
/usr/share/applications/org.xfce.mousepad.desktop
/usr/share/glib-2.0/schemas/org.xfce.mousepad.gschema.xml
/usr/share/glib-2.0/schemas/org.xfce.mousepad.plugins.gspell.gschema.xml
/usr/share/icons/hicolor/128x128/apps/org.xfce.mousepad.png
/usr/share/icons/hicolor/16x16/apps/org.xfce.mousepad.png

...

$(gettext "Summary"):

$(gettext "Represents the package's file system. It is the final content that will be packaged in the .xbps file.")

üìÅ binpkgs

$(gettext "Function"):

$(gettext "Directory where the final .xbps package (from Void Linux) will be stored after creation.")

$(gettext "Example content"):

$(gettext "package-name-version")_1.x86_64.xbps

$(gettext "Summary"):

$(gettext "Final output of the script. Contains the package that can be installed with xbps-install.")

üß† $(gettext "General Summary: 

Folder What is it for?

workdir Temporary workspace (raw contents of the .deb)
datadir Package metadata (control, maintainer, etc.)
destdir Package file system (what will be installed)
binpkgs Final result: the generated .xbps package")

"

}

# ----------------------------------------------------------------------------------------

function log_info() {
	printf "\033[1;36mI\033[0m %s\033[0m\n" "${*}" >&2
}

# ----------------------------------------------------------------------------------------

function log_warn() {
	printf "\033[1;33mW\033[0m %s\033[0m\n" "${*}" >&2
}

# ----------------------------------------------------------------------------------------

function log_crit() {
	printf "\033[1;31mE\033[0;1m %s\033[0m\n" "${*}" >&2
	XDEB_REFUSE=true
}

# ----------------------------------------------------------------------------------------

# Filtra e exibe a vers√£o interna definida no pr√≥prio arquivo.

# Voc√™ pode usar as op√ß√µes como -v ou -version para extrair essa informa√ß√£o automaticamente.


# Extrai a linha que cont√©m "version:" e pega s√≥ o n√∫mero

script_version=$(grep -E "^# version:" "$0" | awk '{print $3}')


version() {

    clear

    msg=$(gettext "%s version: %s")

    # shellcheck disable=SC2059
    printf '%s\n' "$(printf "$msg" "$0" "$script_version")"

}



# ----------------------------------------------------------------------------------------


function sync_shlibs() {
	curl \
		-s "https://raw.githubusercontent.com/void-linux/void-packages/master/common/shlibs" \
		-o "${XDEB_SHLIBS}" \
		-f || {
		log_crit "$(gettext "Unable to sync shlibs.")"
		exit 1
	}
	log_info "$(gettext "Synced shlibs")"
}

# ----------------------------------------------------------------------------------------

# clean : Removes old package data, without removing any binpkgs

function clean() {
	# rm -f "${XDEB_BINPKGS}"/.xbps-pkg-*
	rm -rf "${XDEB_WORKDIR}"
	rm -rf "${XDEB_DATADIR}"
	rm -rf "${XDEB_DESTDIR}"
}

# Ela s√≥ √© chamada explicitamente com -c ou -C.

# ----------------------------------------------------------------------------------------

# clean_repodata : Removes the repodata file. Needed to rebuild a package with the same version

function clean_repodata() {
	rm -rf "${XDEB_BINPKGS}"/*-repodata
}

# ----------------------------------------------------------------------------------------

# clean_all : Remove everything, this script created

function clean_all() {
	clean
	clean_repodata
	rm -rf "${XDEB_BINPKGS}"
	rm -rf "${XDEB_SHLIBS}"
}

# ----------------------------------------------------------------------------------------

function genrdeps() {

	find "${XDEB_DESTDIR}" -type f | while read -r f; do
		[ "$(head -c 4 "${f}" | tr -d '\0')" = "$(printf "\177ELF")" ] || continue
		objdump -p "${f}" | grep NEEDED | awk '{print $2}'
	done | sort -u | while read -r lib; do
		# Ignore libraries provided by current package
		[ -n "$(find "${XDEB_DESTDIR}" -name "${lib}")" ] && continue

		# Escape string
		_lib=$(echo "${lib}" | sed -E 's|\+|\\+|g')
		rdep="$(grep -i -E -m1 "^${_lib}[[:blank:].]+.*$" "${XDEB_SHLIBS}" | cut -d ' ' -f2)"

		[ -z "${rdep}" ] && [ "${XDEB_OPT_LAZY_SONAME}" = true ] && {

            gettext "Unable to find dependency for %s, trying lazy" | xargs -I{} printf '%s\n' "{}" "$lib" | log_warn

			_lib=$(printf "%s" "${_lib}" | sed -E 's|^(.*\.so).*$|\1|g')
			rdep="$(grep -i -E -m1 "^${_lib}[.]+.*$" "${XDEB_SHLIBS}" | cut -d ' ' -f2)"
		}

		[ -z "${rdep}" ] && {
			log_warn "$(gettext "Unable to find dependency for %s"  "${lib}")" >&2
			continue
		}

		printf "%s" "${XDEB_NOT_DEPENDENCIES}" | grep -wF "${rdep%-*}${XDEB_SUFFIX}" >/dev/null && {
			continue
		}

		echo "${rdep%-*}${XDEB_SUFFIX}>=${rdep##*-}"
	done | sort -u | tr '\n' ' '
}

# If 2 arguments, move $1 to $2/$1
# if 3 arguments, move $1 to $2/$3

# ----------------------------------------------------------------------------------------

function fix_conflict() {
	[ ! -e "${XDEB_DESTDIR}/${1}" ] || [ ! -d "${XDEB_DESTDIR}/${1}" ] && return 1

	src="${1}"
	dst="${2}/${3-"${1}"}"
	mkdir -p "${XDEB_DESTDIR}/${2}"
	cp -rT "${XDEB_DESTDIR}/${src}" "${XDEB_DESTDIR}/${dst}"

	# Faz o shell abortar imediatamente com um erro se a vari√°vel XDEB_DESTDIR estiver vazia ou n√£o definida.

    rm -rf "${XDEB_DESTDIR:?}/${src}"

	log_info "$(gettext "Moved conflict '%s' -> '%s'"  "${src}" "${dst}") "
}

# ----------------------------------------------------------------------------------------

# function check_command() {
#	command -v "${1}" > /dev/null 2>&1 || {
#		log_crit "$(printf "$(gettext "Executable '%s' from package '%s' not found.")"  "${1}" "${2-"${1}"}")"
#		exit 1
#	}
# }


# Usar um loop para verificar m√∫ltiplos comandos

function check_command() {

	local missing=0

	for cmd in "$@"; do

		if ! command -v "$cmd" >/dev/null 2>&1; then

            msg=$(gettext "Executable '%s' not found.")
            log_crit "$(printf '%s\n' "$(printf '%s\n' "$msg" | xargs -I{} printf '{}' "$cmd")")"


			missing=1
		fi

	done

	[ "$missing" -eq 1 ] && exit 1

}

# ----------------------------------------------------------------------------------------

function usage() {

    # clear

    echo -e "\n=========================================================================================="
    echo "                 $(gettext "xdeb - Convert Debian packages (.deb) to Void Linux (.xbps)")       "
    echo "=========================================================================================="
    echo -e "\n$(gettext "Version") $script_version"



	cat << EOF

$(gettext "usage"): xdeb [-S] [-d] [-Sd] [--deps] ... $(gettext "FILE")

  -d                          $(gettext "Automatic dependency resolution")
  -S                          $(gettext "Download shlibs file for automatic dependencies")
  -c                          $(gettext "Like -C, excluding shlibs and binpkgs")
  -r                          $(gettext "Remove repodata file (Use for re-building)")
  -R                          $(gettext "Do not register package in repository pool.")
  -q                          $(gettext "Extract .deb into destdir only, do not build")
  -C                          $(gettext "Remove all files created by this script")
  -b                          $(gettext "Build from destdir directly without a .deb file")
  -e                          $(gettext "Remove empty directories from the package")
  -m                          $(gettext "Add the -32bit suffix to the package name")
  -i                          $(gettext "Don't warn if package could break the system")
  -f                          $(gettext "Try to fix certain file conflicts (deprecated)")
  -F                          $(gettext "Don't try to fix certain file conflicts")
  -I                          $(gettext "Automatically install the package")
  -L                          $(gettext "Lazy match SONAMEs")
  --deps=...                  $(gettext "Packages that shall be added as dependencies")
  --not-deps=...              $(gettext "Packages that shall not be used as dependencies")
  --arch=...                  $(gettext "Package arch")
  --name=...                  $(gettext "Package name")
  --version=...               $(gettext "Package version")
  --revision=... --rev=...    $(gettext "Package revision")
  --post-extract=...          $(gettext "File with post-extract commands (i.e. /dev/stdin)")
  --help | -h                 $(gettext "Show help page")
  -version | -v               $(gettext "Show xdeb version")

$(gettext "example"):

  xdeb -Cq                    $(gettext "Remove all files and quit")
  xdeb -Sd FILE               $(gettext "Sync depdendency list and create package")
  xdeb --deps='tar>0' FILE    $(gettext "Add tar as manual dependency and create package")

EOF


intro

	exit "${1}"
}

# ----------------------------------------------------------------------------------------

## Check dependencies

check_command xz
check_command tar
check_command curl

check_command ar 
check_command objdump 

# Gera pacotes XBPS com xbps-create e registra com xbps-rindex.

check_command xbps-rindex 
check_command xbps-create 


check_command python3 gettext realpath awk sed grep ls



# Lista de pacotes obrigat√≥rios

# xbps-query -p pkgver "package"

# Verifica exatamente o pacote, e falha se ele n√£o estiver instalado.

check_packages() {

    local missing=0

    for pkg in "$@"; do

        if ! xbps-query -p pkgver "${pkg}" >/dev/null 2>&1; then

            printf "\n%s\n" "$(gettext "You need to install the %s package on your system." | xargs -I{} printf '{}' "$pkg")"


            missing=1
        fi

    done

    [ "$missing" -eq 1 ] && exit 1
}



check_packages xbps xbps binutils binutils noto-fonts-ttf  # noto-fonts-emoji


# ----------------------------------------------------------------------------------------

## Parse arguments

while [ "${#}" != "0" ]; do
	case "${1}" in
		--deps|--arch|--name|--version|--not-deps|--revision|--rev)

           log_crit "$(gettext "'%s' invalid. Use %s=... instead" | xargs printf "${1}" "${1}")"; exit 1;;

		--deps=*) XDEB_DEPENDENCIES="${XDEB_DEPENDENCIES}${1#*=} "; shift; continue;;
		--conflicts=*) XDEB_CONFLICTS="${XDEB_CONFLICTS}${1#*=} "; shift; continue;;
		--replaces=*) XDEB_REPLACES="${XDEB_REPLACES}${1#*=} "; shift; continue;;
		--provides=*) XDEB_PROVIDES="${XDEB_PROVIDES}${1#*=} "; shift; continue;;
		--arch=*) archs="${1#*=}"; shift; continue;;
		--name=*) pkgname="${1#*=}"; shift; continue;;
		--version=*) version="${1#*=}"; shift; continue;;
		--not-deps=*) XDEB_NOT_DEPENDENCIES="${XDEB_NOT_DEPENDENCIES}${1#*=} "; shift; continue;;
		--revision=*|--rev=*) revision="${1#*=}"; shift; continue;;
		--post-extract=*) XDEB_OPT_POST_EXTRACT="${1#*=}"; shift; continue;;
	    -v|-version) version ; exit 1;;

		--help) usage 0;;
		--) shift; break;;

		--*) # shellcheck disable=SC2059
             log_crit "$(printf "$(gettext "invalid option '%s'")" "${1}")" ; usage 1;;

 		-*);;
		# Posix getopt stops after first non-option
		*) break;;
	esac

	flag="${1#?}"
	while [ -n "${flag}" ]; do
		case "${flag}" in
			S*) sync_shlibs;;
			d*) XDEB_OPT_DEPS=true;;
			h*) usage 0;;
			c*) clean;;
			C*) clean_all;;
			r*) clean_repodata;;
			R*) XDEB_OPT_REGISTER=false;;
			q*) XDEB_OPT_QUIT=true;;
			Q*) exit 0;;
			b*) XDEB_OPT_EXTRACT=false;;
			e*) XDEB_OPT_CLEAN_DIR=true;;
			m*) XDEB_SUFFIX="-32bit";;
			i*) XDEB_OPT_WARN_CONFLICT=false;;
			f*) log_warn "$(gettext "Option '-f' is now enabled by default. Use '-F' to disable it.")";;
			F*) XDEB_OPT_FIX_CONFLICT=false;;
			I*) XDEB_OPT_INSTALL=true;;
			L*) XDEB_OPT_LAZY_SONAME=true;;

			 *) # shellcheck disable=SC2059
                log_crit "$(printf "$(gettext "invalid option -- %s")"  "'${flag%"${flag#?}"}'" )"; usage 1;;
		esac

		flag="${flag#?}"
	done

	shift
done

[ "${#}" = 1 ] && {
	XDEB_BASEPKG="${1}"
}

# ----------------------------------------------------------------------------------------

## Prepare

clean

# Recria diret√≥rios limpos

mkdir -p "${XDEB_PKGROOT}"
mkdir -p "${XDEB_BINPKGS}"
mkdir -p "${XDEB_DATADIR}" && rm -rf "${XDEB_DATADIR:?}"/*
mkdir -p "${XDEB_DESTDIR}" && rm -rf "${XDEB_DESTDIR:?}"/*
mkdir -p "${XDEB_WORKDIR}" && rm -rf "${XDEB_WORKDIR:?}"/*

# Isso garante que workdir, datadir e destdir estejam limpos, mas sem remover a estrutura.


[ "${XDEB_OPT_DEPS}" = true ] && [ ! -r "${XDEB_SHLIBS}" ] && {
	log_crit "$(gettext "shlibs file not synced. Run xdeb with '-Sd' to fetch dependency file")"
	exit 1
}

[ "${XDEB_OPT_EXTRACT}" = true ] && {
	# Is the file readable?
	[ ! -r "${XDEB_BASEPKG}" ] && {
		log_crit "$(gettext "Last argument is not a .deb file or does not exist")"
		exit 1
	}


# Qualquer falha dentro do bloco { ... } executa o || { ... }.
{
    ar -xf "${XDEB_BASEPKG}" --output "${XDEB_WORKDIR}" &&
    tar -xf "${XDEB_WORKDIR}"/control.* -C "${XDEB_DATADIR}" &&
    tar -xf "${XDEB_WORKDIR}"/data.* -C "${XDEB_DESTDIR}"
} || {
    log_crit "$(gettext "Not a valid deb file, one of the extraction steps failed")"
    exit 1
}



	log_info "$(gettext "Extracted files")"
}

# Quit after parsing every argument argument

[ "${XDEB_OPT_QUIT}" = true ] && {
	log_info "$(gettext "Quitting before building")"
	exit 0
}

# ----------------------------------------------------------------------------------------

## Parse

[ -z "${pkgname}" ] && \
	pkgname="$(grep -Po -m1 "Package:[ \t]*\K.*" "${XDEB_DATADIR}/control")"
[ -z "${version}" ] && \
	version="$(grep -Po -m1 "Version:[ \t]*\K.*" "${XDEB_DATADIR}/control")"
[ -z "${license}" ] && \
	license="$(grep -Po -m1 "License:[ \t]*\K.*" "${XDEB_DATADIR}/control")"
[ -z "${maintainer}" ] && \
	maintainer="$(grep -Po -m1 "Maintainer:[ \t]*\K.*" "${XDEB_DATADIR}/control")"
[ -z "${short_desc}" ] && \
	short_desc="$(grep -Po -m1 "Description:[ \t]*\K.*" "${XDEB_DATADIR}/control")"
[ -z "${long_desc}" ] && \
	long_desc="$(grep -Po -m1 -z "Description:[ \t\n]*\K.*" "${XDEB_DATADIR}/control" | tr '\0' '\n')"
[ -z "${archs}" ] && \
	archs="$(grep -Po -m1 "Architecture:[ \t]*\K.*" "${XDEB_DATADIR}/control")"

pkgname="${pkgname}${XDEB_SUFFIX}"

# if not short_desc: short_desc=long_desc
# if not long_desc: long_desc=short_desc
if [ -z "${short_desc}" ] && [ -z "${long_desc}" ]; then
	log_crit "$(gettext "Neither long_desc nor short_desc provided by package")"
	exit 1
elif [ -z "${short_desc}" ]; then
	short_desc="${long_desc}"
elif [ -z "${long_desc}" ]; then
	long_desc="${short_desc}"
fi

# debian_epoch="$(printf "%s" "${version}" | grep -Po '^[0-9]+(?=:)')"
# debian_revision="$(printf "%s" "${version}" | grep -Po '\-\K[A-Za-z+.~]+$')"

# [ -n "${debian_revision}" ] && \
# 	version="${version%-"${debian_revision}"}"

# [ -z "${revision}" ] && \
# 	revision="${debian_revision}"

[ -z "${revision}" ] && \
	revision="1"

version="$(printf "%s" "${version}" | sed 's|[-_/]|.|g; s/^[^0-9]*$/\00/g; s/^$/0/g')"
revision="$(printf "%s" "${revision}" | sed 's|[^0-9]||g')"

case "${archs}" in
	amd64) archs="x86_64";;
	arm64) archs="aarch64";;
	armhf) archs="armv7l";;
	i386) archs="i686";;
	all) archs="noarch";;
	*)
        log_crit "$(gettext "Invalid arch: %s. Use '--arch=...' to set arch manually." | xargs printf "$archs")"

		exit 1

		;;
esac

# ----------------------------------------------------------------------------------------

## Build

[ "${XDEB_OPT_FIX_CONFLICT}" = true ] && {
	python3_version="$(python3 --version | sed 's/.*\([0-9]\+\.[0-9]\+\)\.[0-9]\+/\1/')" || exit 1

	fix_conflict bin       usr
	fix_conflict lib       usr
	fix_conflict lib32     usr
	fix_conflict lib64     usr
	fix_conflict sbin      usr bin
	fix_conflict usr/sbin  usr bin
	fix_conflict usr/lib64 usr lib
	fix_conflict usr/lib/python3/dist-packages "usr/lib/python${python3_version}" site-packages
}

[ -n "${XDEB_OPT_POST_EXTRACT}" ] && {
	cd "${XDEB_DESTDIR}" || exit 1

   # SC1090 (warning): ShellCheck can't follow non-constant source. Use a directive to specify location.
   # O valor de XDEB_OPT_POST_EXTRACT √© uma vari√°vel, e o ShellCheck n√£o sabe exatamente qual arquivo ser√° inclu√≠do.

   # shellcheck source=/dev/null
	. "${XDEB_OPT_POST_EXTRACT}" || exit 1
}

[ "${XDEB_OPT_DEPS}" = true ] && XDEB_DEPENDENCIES="${XDEB_DEPENDENCIES}$(genrdeps)"

# Remove trailing space
XDEB_DEPENDENCIES="${XDEB_DEPENDENCIES%* }"

# shellcheck disable=SC2059
[ -n "${XDEB_DEPENDENCIES}" ] && echo -e " " &&  msg=$(gettext "Resolved dependencies: (%s)") && log_info "$(printf "$msg" "${XDEB_DEPENDENCIES}")" && echo -e " "     

# shellcheck disable=SC2059

# log_info "$(gettext "Resolved dependencies (%s)" | xargs printf "%s\n" "${XDEB_DEPENDENCIES}")"



if [ "${XDEB_OPT_CLEAN_DIR}" = true ] || [ "${XDEB_OPT_WARN_CONFLICT}" = true ]; then

    if command -v xbps-query >/dev/null; then
        ign="$(xbps-query -f "${pkgname}" | sed 's/ -> .*//')"
    fi

    find "${XDEB_DESTDIR}" -depth -mindepth 1 | (

        # Se nenhum conflito for encontrado, rc poderia n√£o estar definido, e o exit ${rc-0} ainda funciona, mas n√£o √© limpo.

        rc=0

		while read -r f; do
			# Remove empty directories
			[ "${XDEB_OPT_CLEAN_DIR}" = true ] && [ -z "$(ls -A "${f}")" ] && {
				rm -rf "${f}"

                 msg=$(gettext "Removed empty directory %s")
                 # shellcheck disable=SC2059
                 log_info "$(printf "$msg" "${f}")"

				continue
			}

			# Check for conflicts
			[ "${XDEB_OPT_WARN_CONFLICT}" != true ] && continue

			fr="${f#"${XDEB_DESTDIR}"}"
			[ ! -e "${fr}" ] && continue
			[ ! -L "${fr}" ] && [ -d "${fr}" ] && [ ! -L "${f}" ] && [ -d "${f}" ] && continue

			echo "${ign}" | grep -q -x -F "${fr}" && continue
			[ -z "$(ls -A "${f}")" ] && {

                 msg=$(gettext "Conflict: '%s'. Use '-e' to remove automatically.")
                 # shellcheck disable=SC2059
                 log_crit "$(printf "$msg" "${f#"${PWD}/"}")"

			} || {

                 msg=$(gettext "Conflict: '%s'")
                 # shellcheck disable=SC2059
                 log_crit "$(printf "$msg" "${f#"${PWD}/"}")"

			}
			rc=1
		done

		exit "${rc-0}"

   ) || { 
    # msg=$(gettext "Consider (re)moving file(s) from '%s' and run `xdeb -rb`")
    msg=$(gettext "Consider (re)moving file(s) from '%s' and run \`xdeb -rb\`")
 

    # shellcheck disable=SC2059
    log_crit "$(printf "$msg" "$XDEB_DESTDIR")"
    }


fi


# ----------------------------------------------------------------------------------------


## Abortar se houve falhas anteriores

if [ "${XDEB_REFUSE}" = true ]; then

	log_crit "$(gettext "Errors occurred earlier. Aborting before package creation or installation.")"

	exit 1
fi


# Verificar XDEB_REFUSE antes do xbps-create e do xbps-install.

# ----------------------------------------------------------------------------------------

## Package

cd "${XDEB_BINPKGS}" || exit 1

out="${pkgname}-${version}_${revision}"
if ! xbps-create \
	-q \
	-t xdeb \
	-A "${archs}" \
	-n "${out}" \
	-m "${maintainer}" \
	-s "${short_desc}" \
	-S "${long_desc}" \
	-l "${license}" \
	-D "${XDEB_DEPENDENCIES}" \
	-C "${XDEB_CONFLICTS}" \
	-R "${XDEB_REPLACES}" \
	-P "${XDEB_PROVIDES}" \
	--build-options "${XDEB_BUILD_OPTIONS}" \
	"${XDEB_DESTDIR}"; then
	log_crit "$(gettext "xbps-create failed. Package not created.")"
	exit 1
fi

[ "${XDEB_OPT_REGISTER}" = true ] && {

	xbps-rindex -a "${out}.${archs}.xbps" >&2

}

[ -t 1 ] || echo "${XDEB_BINPKGS#"${PWD}/"}/${out}.${archs}.xbps"

# ----------------------------------------------------------------------------------------

## Install

if [ "${XDEB_OPT_INSTALL}" = true ]; then




installer=$(command -v sudo doas 2>/dev/null | head -n1)

# Executa o comando de instala√ß√£o com verifica√ß√£o direta
if "$installer" xbps-install -R "${XDEB_BINPKGS#"${PWD}/"}" "${out}"; then

    # notify-send "‚úîÔ∏è Sucesso" ""
    echo -e "\n"

    # Verifica se o pacote foi instalado
    xbps-query -l | grep -F -- "${out}"

    echo -e "\n"

    xbps-query -S "${out}"

    # echo -e "\n$(printf "$(gettext "To remove the package:\nsudo xbps-remove -y %s")" "${out}")"

    # shellcheck disable=SC2059
    echo -e "\n$(printf "$(gettext "To remove the package: 

sudo xbps-remove -y %s")" "${out}")"

    # notify-send "‚úîÔ∏è Pacote instalado" "$(gettext 'Use o comando para remover:\n')sudo xbps-remove -y ${out}"

else

    # Voc√™ pode descomentar estas linhas se quiser lidar com falha

    # notify-send "‚ùå Erro" ""

    echo "Erro ao instalar o pacote: ${out}"

fi





else

    # Forma segura (e correta) de resolver o SC2059:

    echo -e "\n"

    # shellcheck disable=SC2059
    # log_info "$(printf "$(gettext 'Install using `xbps-install -R %s %s `')" "${XDEB_BINPKGS#"${PWD}/"}" "${out}")"

    # Aspas simples impedem a expans√£o de vari√°veis ou comandos. gettext tamb√©m precisa de cuidado com escape.

    log_info "$(gettext "Install using \`xbps-install -R %s %s \`" | xargs printf "${XDEB_BINPKGS#"${PWD}/"}" "${out}")"



# Explica√ß√£o:

# gettext retorna a string com os %s.

# xargs printf '%s\n' trata essa string como formato, aplicando os argumentos.

# O uso do -0 (ou --null) em xargs depende de seu sistema ‚Äî remova se necess√°rio.

    echo -e " "

    # ls -lh "${XDEB_BINPKGS#"${PWD}/"}" | grep "${out}"

    # ls | grep pode falhar com nomes de arquivos que contenham espa√ßos, acentos ou caracteres especiais.

    for file in "${XDEB_BINPKGS#"${PWD}/"}"/*; do

        if [[ "$file" == *"$out"* ]]; then

            ls -lh "$file"

        fi

    done


    # shellcheck disable=SC2059
    echo -e "\n$(printf "$(gettext "To remove the package: 

sudo xbps-remove -y %s")" "${out}")"

fi

# ----------------------------------------------------------------------------------------


# Exemplo:


# $ xdeb -e dissenter-browser_1.5.114_amd64.deb

# I Arquivos extra√≠dos
# index: skipping `dissenter-browser-1.5.114_1' (x86_64), already registered.
# index: 1 packages registered.


# I Instalar usando `xbps-install -R /tmp/xdeb/binpkgs dissenter-browser-1.5.114_1 `
 
# -rw-r--r-- 1 anon anon 77M set  8 01:49 dissenter-browser-1.5.114_1.x86_64.xbps



# sudo xbps-install -R /tmp/xdeb/binpkgs dissenter-browser-1.5.114_1

# Name              Action    Version           New version            Download size
# dissenter-browser install   -                 1.5.114_1              - 

# Size required on disk:         216MB
# Space available on disk:      3499MB

# Do you want to continue? [Y/n] Y

# [*] Verifying package integrity
# dissenter-browser-1.5.114_1: verifying SHA256 hash...

# [*] Collecting package files
# dissenter-browser-1.5.114_1: collecting files...

# [*] Unpacking packages
# dissenter-browser-1.5.114_1: unpacking ...

# [*] Configuring unpacked packages
# dissenter-browser-1.5.114_1: configuring ...
# dissenter-browser-1.5.114_1: installed successfully.

# 0 downloaded, 1 installed, 0 updated, 1 configured, 0 removed, 0 on hold.


# xbps-query -l | grep dissenter-browser
# ii dissenter-browser-1.5.114_1               The web browser from Dissenter


# $ xbps-query -S dissenter-browser
# architecture: x86_64
# filename-sha256: 838e84db3a21979692d977a9ba9109d00b61ee8f486c269b39b2fc8b441ec4a1
# filename-size: 77MB
# install-date: 2025-09-08 01:27 UTC
# installed_size: 216MB
# long_desc: The web browser from Dissenter
# maintainer: Gab AI Inc <support@dissenter.com>
# metafile-sha256: e30cda634b9287254b5308b2a243fb6794db8a8d551e5cb318db1f9cc034d362
# pkgname: dissenter-browser
# pkgver: dissenter-browser-1.5.114_1
# repository: /tmp/xdeb/binpkgs
# short_desc: The web browser from Dissenter
# state: installed
# tags: xdeb

#  =================================================================================

# xdeb -Sde dissenter-browser_1.5.114_amd64.deb

# I Shlibs sincronizadas
# I Arquivos extra√≠dos
 
# I Depend√™ncias resolvidas: (alsa-lib>=1.0.20_1 at-spi2-atk>=2.6.0_1 at-spi2-core>=1.91.91_1 atk>=1.26.0_1 cairo>=1.8.6_1 dbus-libs>=1.2.10_1 expat>=2.0.0_1 gdk-pixbuf>=2.22.0_1 glib>=2.80.0_1 glibc>=2.41_1 gtk+3>=3.0.0_1 libX11>=1.2_1 libXScrnSaver>=1.1.3_1 libXcomposite>=0.4.0_1 libXcursor>=1.1.9_1 libXdamage>=1.1.1_1 libXext>=1.0.5_1 libXfixes>=4.0.3_1 libXi>=1.2.1_1 libXrandr>=1.3.0_1 libXrender>=0.9.4_1 libXtst>=1.0.3_1 libcups>=1.5.3_1 libgcc>=4.4.0_1 libxcb>=1.2_1 nspr>=4.8_1 nss>=3.12.4_1 pango>=1.24.0_1)
 
# index: skipping `dissenter-browser-1.5.114_1' (x86_64), already registered.
# index: 1 packages registered.


# I Instalar usando `xbps-install -R /tmp/xdeb/binpkgs dissenter-browser-1.5.114_1 `
 
# -rw-r--r-- 1 anon anon 77M set  8 02:42 dissenter-browser-1.5.114_1.x86_64.xbps

#  =================================================================================




exit 0

